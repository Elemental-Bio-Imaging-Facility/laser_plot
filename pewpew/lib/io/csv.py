import numpy as np
import os

from pewpew import __version__
from pewpew.lib.exceptions import (
    PewPewCalibrationError,
    PewPewConfigError,
    PewPewDataError,
    PewPewFileError,
)
from pewpew.lib.laser import Laser, LaserConfig, LaserData

from typing import Tuple


# TODO add an option to choose calibration on save, as you can now toggle it on and off


def load(
    path: str,
    isotope: str = "None",
    config: LaserConfig = None,
    read_config: bool = True,
    read_calibration: bool = True,
) -> Laser:
    """Imports the given CSV file, returning a LaserData object.

    Each row of the CSV is read as a line of laser data.
    An optional # commented header (see exportCsv) containing
    configuration data may also be read.

    Args:
        path: Path to the CSV file
        isotope: Name of the isotope
        config: Laser configuration to apply
        read_config: If True, attempts to read config from header data
        read_calibration: If True, attempts to read calibration from header data

    Returns:
        The LaserData object.

    Raises:
        PewPewFileError: Malformed file.
        PewPewConfigError: Invalid config.
        PewPewDataError: Invalild data.

    """

    with open(path, "r") as fp:
        line = fp.readline().lstrip("#").strip()
        if line.startswith("Pew Pew "):  # CSV generated by pewpew
            # Version
            version = line[8:]
            if version < "0.5.0":
                raise PewPewFileError(f"Unsupported CSV version '{version}'.")
            # Isotope
            line = fp.readline().lstrip("#").strip()
            if "=" not in line:
                raise PewPewFileError(f"Malformed name line '{line}'.")
            _, isotope = line.split("=")
            # Config
            if read_config or read_calibration:
                line = fp.readline().lstrip("#").strip()
                if read_config:
                    if config is None:
                        config = LaserConfig()
                    try:
                        spotsize, speed, scantime = line.split(";")
                        config.spotsize = float(spotsize.split("=")[1])
                        config.speed = float(speed.split("=")[1])
                        config.scantime = float(scantime.split("=")[1])
                    except (KeyError, ValueError):
                        raise PewPewConfigError(f"Malformed config line '{line}'")
            # Calibration
            if read_calibration:
                line = fp.readline().lstrip("#").strip()
                try:
                    tokens = line.split(";")
                    intercept = float(tokens[0].split("=")[1])
                    gradient = float(tokens[1].split("=")[1])
                    unit = tokens[2].split("=")[1]
                except (KeyError, ValueError):
                    raise PewPewCalibrationError(f"Malformed calibration line '{line}'")

        try:
            data = np.genfromtxt(fp, delimiter=",", dtype=np.float64, comments="#")
        except ValueError as e:
            raise PewPewFileError("Could not parse file.") from e

    if data.ndim != 2:
        raise PewPewDataError(f"Invalid data dimensions '{data.ndim}'.")

    laser = Laser(
        config=config, name=os.path.splitext(os.path.basename(path))[0], filepath=path
    )
    # Only put calibration in if requested
    if read_calibration:
        laser.data[isotope] = LaserData(
            data, isotope, intercept=intercept, gradient=gradient, unit=unit
        )
    else:
        laser.data[isotope] = LaserData(data, isotope)

    return laser


def save(
    path: str,
    laser: Laser,
    name: str,
    calibrate: bool = False,
    extent: Tuple[float, float, float, float] = None,
    include_header: bool = False,
) -> None:
    header = ""
    if include_header:
        config = laser.config
        # calibration = laser.calibration
        header = (
            f"Pew Pew {__version__}\nname={name}\n"
            f"spotsize={config.spotsize};speed={config.speed};"
            f"scantime={config.scantime}\n"
            f"intercept={laser.data[name].intercept};"
            f"gradient={laser.data[name].gradient};"
            f"unit={laser.data[name].unit}\n"
        )
    np.savetxt(
        path,
        laser.get(name, calibrate=calibrate, extent=extent),
        delimiter=",",
        header=header,
    )
